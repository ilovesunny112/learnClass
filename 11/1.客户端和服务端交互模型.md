 - http
    + 一个页面从访问到加载经历的事情
    + http报文及http事务
    + 前端优化
 - node基础
    + npm包管理
    + node基础api
    + 基于node搭建一个简单的后台服务
 - ajax及库的封装
    + ajax基础知识
    + 基于promise封装ajax库
    + axios
    + fetch
 - 全栈案例：crm或者投票或者其他
 - 跨域请求
   - jsonp
   - cros
   - 本地虚拟
   - ....
   - 



### 客户端和服务端交互模型
- 概念
  + 客户端：所有可以向服务端发送请求的一端都是客户端
  + 服务端： 所有可以接受客户端的请求，并且给其相应一些内容的都是服务端 
- 客户端和服务端交互
- step
  1. 浏览器首先向DNS域名解析服务器发送请求
  2. DNS反解析：根据浏览器请求地址中的域名，到DNS服务器中找到对应的服务器外网IP地址
  3. 通过找到的外网IP，向对应的服务器发送请求（首先访问的是服务器的WEB站点管理：准确来说先基于工具在服务器谁给你创建很多服务，当有客户端访问的时候，服务器会匹配出具体是请求哪个服务）
  4. 通过url地址中携带的端口号，找到服务器上对应的服务，以及服务所管理的项目源文件
  5. 服务器根据请求地址中的路径名称，问好或者哈希值，把客户端需要的内容进行转呗和处理
  6. 把准备的内容相应给客户端（如果请求的是HTML或者CSS等这样的资源文件，服务器返回的是资源文件中的源代码）【不是文件本身】
  7. 客户端浏览器接受到服务器返回的源代码，基于自己内部的渲染引擎（内核）开始进行页面的绘制和渲染
    - 首先计算DOM结构生成DOM TREE
    - 自行而下运行代码，加载css等资源内容
    - 根据获取的css生成带样式的redner tree
    - 开始渲染和绘制
   8. 我们把一次完整的 请求+相应 称之为“http事务”事务就是完整的一次操作，请求和相应缺一不可
   9. 一个页面完全加载完成，需要向服务器发起很多次http事务操作。一般来说：首先把HTML源代码拿出来，加载html的时候，遇到link/scrpit/img.iframe/video/audio都会简历http事务交互
      -  特殊情况：如图我们做了资源缓存处理304，而且即将加载的资源在之前加载过了，这样的操作和传统的http事务有所不一样，他们是从服务器和浏览器的缓存中读取数据，比传统的读取块很多
 10. 在客户端想服务器请求，以服务端把内容相应给客户端的时候，中间互相传递了很多内容（客户端吧一些内容传递服务器，服务器把一些内容相应给客户端），我们把传递的内容统称为“http报文”


`优化 减少请求`



### 一个完整URL的各部分分析

- url/urn/uri
  + URI: 统一资源标识符
  + URL: 统一资源定位符
  + URN: 统一资源名称
- https://www.duba.com/?f=qd_sch
   + 传输协议：
   + http: 超文本传输协议（除了传递文本，还可以传递文件流或者进制编码等信息），是目前常用的web传输协议
   + https: ssl+http,加密http传输协议，相比安全
   + ftp： 文件传输协议，一般用来实现资源文件在服务器上的上传下载
- 域名
   +  一级二级三级
- 端口号
   + 用来区分同一台服务器上不同服务的标识（基于web服务管理器创建服务的时候可以指定），不同服务之间一般是不能使用相同的端口号的（80/443/21）
   + 如果当前网站服务采用的协议对应的默认端口管理，那么当用户输入网址的时候可以不指定端口号，浏览器会默认把用户把默认的端口号传递给服务器
   + 端口号范围：0到65535
- 请求路径名称
- 问号传参和哈希值
  + protocol 协议
  + host 带端口的域名
  + hostname 域名
  + port 端口号
  + pathname 请求的物理路径
  + search 参数
  + hash 获取对应的hash值
  + href 本页面地址


### http报文
> 起始行：请求起始行，相应起始行
> 首部（头）：请求头，响应头，通用头
> 主体：请求主体和相应主体

- 通用头
  + Request URL:https://www.baidu.com/
  + Request Method:GET
  + Status Code:200 OK
  + Remote Address:111.13.100.92:443  
  + Referrer Policy:no-referrer-when-downgrade
- Request Headers
	 + GET / HTTP/1.1 起始行（描述当前请求的一些基本信息：用1.1版本传输协议进行内容传输的）
	 + Host: www.caixin.com
	 + Connection: keep-alive 
	 + Cache-Control: max-age=0
	 + Upgrade-Insecure-Requests: 1
	 + User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36 当前客户端的终端浏览器
	 + Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
	 + Accept-Encoding: gzip, deflate
	 + Accept-Language: zh-CN,zh;q=0.9
     + Cookie: 一般都是放到头文件中实现和服务端的数据通信的
   - Response Headers 响应头
     + HTTP/1.1 200 OK 相应起始行
	 + Date: Sun, 15 Jul 2018 04:23:31 GMT 相应内容时候服务器的时间
	+ Content-Type: text/html; charset=UTF-8
	+ Transfer-Encoding: chunked
	+ Connection: keep-alive
	+ Server: nginx/1.6.0 管理web服务的工具
	+ Vary: Accept-Encoding
	+ Cache-Control: no-cache
	+ Pragma: no-cache
	+ Content-Encoding: gzip
Responese 响应主体
Request paylog/Form Data 请求主体
#### 客户端和服务端交信息交互方式
[客户端给服务端]
问号传参
设置请求头
设置请求主体

[服务端返回给客户端]
设置响应头信息，例如把服务时间通过响应头返回给客户端，客户端通过获取响应头信息得到这个时间（响应头返回的速度是优先于响应主体的）
设置响应主体，
重要信息都在响应主体中



### 	前端性能优化技巧
-  js中尽量减少闭包的使用  （闭包会产生不释放的栈内存）
   + 循环给元素做事件绑定的时候，尽可能把后期需要的信息（例如索引）存储元素的自定义属性上，而不是创建闭包存储
   + 可以在外层形成一个闭包，把一些后续需要的公共信息进行存储，而不是每一个方法都创建闭包（例如单例模式）
   + 尽可能的手动释放不被占用的内存
- 尽量合并css和js文件（把需要引入的css合并一个）原理是减少http请求次数，尽可能把合并后的代码进行压缩，减小请求大小
   + 构建工具进行合并压缩
   + 移动开发（或者追求高性能的pc端开发），如果代码不对的话可以搞成内嵌式（也可以减少请求）
- 尽量使用字体图标或者SVG图标，来代替传统的PNG等格式的图片（因为字体图标等是矢量图，方法不会变形和失真，渲染快，相比位图要小一些）
- 减少对DOM的操作（主要是减少DOM的重绘和回流（重排））
   + 关于重排的分离读写
   + 使用文档碎片或者字符串拼接做数据绑定
- 在js中避免嵌套循环（这种会额外增加很多循环次数）和死循环（一旦遇到死循环浏览器就卡壳了）
- 采用图片的懒加载（延迟加载）
  + 目的是为了减少页面第一次加载过程中HTTP的请求次数，让页面打开速度快
  + 步骤：开始加载页面的时候，所有的真实图片都不去发送HTTP请求加载，而是给一张占位的背景图，当页面加载完，并且图片在可视区域内我们图片加载 
- 利用浏览器和服务端的缓存技术304，把一些不经常更新的静态资源文件做缓存处理
- 尽可能使用事件委托（代理）减少频繁dom的操作，其中包括给每一个dom元素做事件绑定
- 尽量减少css的表达式使用
- css选择器解析规则是从右到左解析
- 重量级优化： 做CDN加速（烧钱机器）
- css雪碧图技术（css sprite）
- 减少对于cookie的使用（最主要的是减少本地cookie存储内容的大小），因为客户端操作cookie的时候，这些信息总是在客户端和服务端传来传去
- 页面中的数据获取采用异步编程和延迟分批加载
  +  使用异步获取数据，是为了降低http通道堵塞，不会因为数据没有请求回来耽误下面信息的渲染，提高页面的打开速度（我们可以这样处理：需要动态绑定数据的区域先隐藏，等数据返回并且绑定完成后让其显示）
- 页面中出现音视频标签，我们不让页面加载的时候就去加载这些资源（只要设置preload='node'即可），等待页面加载完成音视频播放的时候我们去加载音视频资源
- 尽可能实现js的封装（低耦合高内聚），减少页面中的多余代码（减少http请求的大小）
- css中设置定位后最好用z-index改变盒子层级，让所有的盒子不在相同的平面上，这样后续处理的时候
- 尽量减少对于filter滤镜属性的使用消耗性能太大
- 开启服务端的gzip压缩
- js动画window.requestAnimationFrame
- 减少递归的使用
- 避免使用iframe
- 利用h5中提供的localstorage本地存储或者是manifest离线缓存，做一些信息的本地存储，下一次加载页面的时候直接本地获取，减少请求
- 基于script调用js的时候，可已使用defer或者async来异步加载
- 把css放到body上js放到下
- 能用css绝对不用js,不适用flash

### 全局刷新和局部刷新
ajax介绍
前后不分离
有利于seo，速度快
全局刷新，页面刷新
ajax局部刷新

### ajax操作
1. 创建ajax实例
   + let xhr = new XMLHttpRequest() //ie中使用的不兼容
   + new ActiveXObject();
2. 打开请求：发送请求之前的一些配置项
  + xhr.open([http method],[url],[async],[user-name],[user-password])
  + method请求方式：get,delete,head,options/trace/connect,    post put
  + url api地址
  + 设置ajax异步同步，默认异步，防止代码阻塞（true异步）  
  + 服务器开启匿名验证
3. 事件监听：一般监听的都是ready-state-change事件（ajax状态改变事件），基于这个事件可以获取服务器返回的响应头相应体的内容
  + xhr.onreadystatechange = function() {
  +    if(xhr.readyState  \===  4 &&  xhr.status  \=== 200) {
  +            xhr.responseText;
  +    }
  +  }
4. 发送ajax请求，从这步开始，当前ajax任务开始，如果ajax是同步的，后续代码不会执行，要等到ajax状态成功后在执行，反之异步不会！xhr.send([请求主体内容])

#### 关于http请求方式的一点学习
所有的请求都可以给服务器端传递内容，也都可以从服务端获取内容
- get： 从服务端获取数据（给的少拿的多）
- post:  想服务端提交推送数据（给的多拿的少）
- delete:  删除服务端的某些内容（一般是删除一些文件）
- put: 想服务器上存放一些内容（一般般也是文件）
- head: 只想获取服务器返回的响应头信息，不要相应主体中的内容
	- options:  一般使用它向服务器发送一个探测性请求，如果服务器端返回了信息，说明当前客户端和服务器建立了链接，我们可以继续执行其他请求了。（trace是干这件事的但是axios这个ajax类库在基于cross domian进行跨域请求的时候，就是先发送options请求进行探测尝试，然后能连通服务器，才会继续发送其他请求）

#### get vs post 
[传递给服务器信息的方式不一样的]
get是基于url地址“问号传参的方式”把信息传递给服务器，post是基于请求主体把信息传递给服务器
get 一般应用于拿（给服务器的会少一些），而post给服务器的很多，如果post是基于问号传参方式来搞会出现一些问题：url会拼接很长，浏览器对于url的长度有有最大限度（谷歌8kb火狐7kb ie2kb ...）超过的部分浏览器就会把它截取掉
[get不安全，post相对安全]
因为get是基于“问号传参”把信息传递给服务器的，容易被骇客进行url劫持
[get会产生不肯控制的缓存，post不会]
不可控：不是想要就要，想不要就不要的，这是浏览器自主记忆的缓存，我们无法基于js控制，真实项目中我们都会把这个缓存干掉
_=Math.random()


### ajax状态和http网络状态码 
#### ajax状态
0：unsent 刚开始创建xhr,还么有发送
1：opened 已经执行了open这个操作
2：headers_received 已经发送ajax请求（ajax任务开始，响应头信息已经被客户端接收了，服务器的时间，返回http状态码） 
3：loading 相应主体内容正在返回
4：done 响应主体被客户端接受

#### http网络状态码
根据状态码能够清楚的反映出当前交互的结果及原因
  200 ok  成功（只能证明返回信息成功了，但不一定是你业务需要的）
  301 moved permanently 永久重定向
  302 临时重定向
  400 请求参数错误
  404 找不到资源
  500 未知服务器错误
  503 服务器超负荷 

### ajax中常用的属性和方法

  